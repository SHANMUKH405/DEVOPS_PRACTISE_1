# ============================================================================
# NGINX CONFIGURATION
# ============================================================================
# Nginx is a web server that acts as a reverse proxy
# 
# What is a reverse proxy?
# - Receives requests from users
# - Forwards them to the appropriate backend service
# - Returns the response to the user
#
# Benefits:
# - Load balancing (distribute requests across multiple servers)
# - SSL termination (handle HTTPS)
# - Caching (store responses for faster delivery)
# - Single entry point (users only see one URL)
# ============================================================================

# Events block - configuration for how Nginx handles connections
events {
    worker_connections 1024;  # Maximum connections per worker process
}

# HTTP block - configuration for HTTP traffic
http {
    # ------------------------------------------------------------------------
    # UPSTREAM - Define Backend Services
    # ------------------------------------------------------------------------
    # This tells Nginx where to send requests
    # "webapp" is the name we give to our backend
    # "web:5000" is the service name and port from docker-compose.yml
    # Docker Compose creates a network where services can find each other by name
    
    upstream webapp {
        server web:5000;  # Forward to our Flask app (service name from docker-compose.yml)
        # You could add more servers here for load balancing:
        # server web:5000;
        # server web2:5000;
        # server web3:5000;
    }

    # ------------------------------------------------------------------------
    # SERVER BLOCK - Main Server Configuration
    # ------------------------------------------------------------------------
    # This defines how Nginx handles incoming requests
    
    server {
        listen 80;              # Listen on port 80 (standard HTTP port)
        server_name localhost;  # Server name (for virtual hosting)

        # --------------------------------------------------------------------
        # LOCATION BLOCK - Route All Requests
        # --------------------------------------------------------------------
        # This handles all requests to "/" (the root path)
        location / {
            # Forward requests to our Flask app
            proxy_pass http://webapp;
            
            # Set headers so the Flask app knows the original request details
            proxy_set_header Host $host;                    # Original host
            proxy_set_header X-Real-IP $remote_addr;        # Client's real IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # Forwarded IPs
            proxy_set_header X-Forwarded-Proto $scheme;     # HTTP or HTTPS
        }

        # --------------------------------------------------------------------
        # HEALTH CHECK ENDPOINT
        # --------------------------------------------------------------------
        # Special handling for health checks
        # access_log off = Don't log these requests (reduce log noise)
        location /health {
            proxy_pass http://webapp/health;
            access_log off;  # Don't log health checks
        }
    }
}

# ============================================================================
# HOW THIS WORKS
# ============================================================================
# 
# 1. User visits http://localhost:80
# 2. Nginx receives the request
# 3. Nginx forwards it to http://web:5000 (our Flask app)
# 4. Flask app processes the request and returns a response
# 5. Nginx returns the response to the user
#
# Benefits:
# - Users only see port 80 (standard HTTP)
# - Nginx can handle multiple backend services
# - Easy to add load balancing later
# - Can add SSL/HTTPS easily
#
# ============================================================================
